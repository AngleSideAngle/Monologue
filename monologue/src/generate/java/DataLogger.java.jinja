package monologue;

import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.networktables.NTSendable;
import edu.wpi.first.wpilibj.smartdashboard.SendableBuilderImpl;
import edu.wpi.first.util.datalog.*;
import edu.wpi.first.util.sendable.Sendable;
import edu.wpi.first.wpilibj.DataLogManager;
import java.util.Arrays;
import java.util.function.Supplier;
import java.util.function.LongConsumer;
import edu.wpi.first.util.struct.Struct;

class DataLogger extends GenericLogger {
    private DataLog log = DataLogManager.getLog();

    public DataLogger() {
        super();
        DataLogManager.logNetworkTables(false);
    };

    {%for t in types%}

    @Override
    public void put(String entryName, {{t.java.ValueType}} value, LogLevel level)
    {
        if (level == LogLevel.NOT_FILE_ONLY && Monologue.isFileOnly()) {
            return;
        }
        {%if t.java.ValueType == 'String'%}
        if (value == null) {return;}
        {%endif%}
        {%if t.java.IsArray%}
        if (value == null) {return;}
        {%endif%}
{%if t.TypeName == 'IntegerArray'%}
        new {{t.java.EntryName}}LogEntry(log, entryName)
            .append(toLongArray(value));
{%else%}
        new {{t.java.EntryName}}LogEntry(log, entryName).append(value);
{%endif%}
    }

    @Override
    public void add{{t.TypeName}}(String entryName,
    {{t.java.Supplier}}valueSupplier,
    LogLevel level)
    {
        var entry = new {{t.java.EntryName}}LogEntry(log, entryName);

        LongConsumer consumer;
{%if t.TypeName == 'IntegerArray'%}
        if (this.isLazy()) {
            consumer = new LongConsumer() {
                private long[] lastValue = new long[] {};
                @Override
                public void accept(long timestamp) {
                    var intarr = valueSupplier.get();
                    if (intarr == null) {return;}
                    var value = toLongArray(valueSupplier.get());
                    if (!(Arrays.equals(value, lastValue))) {
                        entry.append(value, timestamp);
                        lastValue = value;
                    }
                }
            };
        } else {
            consumer = (timestamp) -> {
                var value = valueSupplier.get();
                if (value == null) {return;}
                entry.append(toLongArray(value), timestamp);
            };
        }

        addField(
            entryName,
            level,
            consumer
        );
{%elif t.java.IsArray == true%}
        if (this.isLazy()) {
            consumer = new LongConsumer() {
                private {{t.java.ValueType}} lastValue = new {{t.java.ValueType}} {};
                @Override
                public void accept(long timestamp) {
                    var value = valueSupplier.get();
                    if (value == null) {return;}
{%if t.TypeName == 'StringArray'%}
                    if (!(Arrays.deepEquals(value, lastValue))) {
{%else%}
                    if (!(Arrays.equals(value, lastValue))) {
    {%endif%}
                        entry.append(value, timestamp);
                        lastValue = value;
                    }
                }
            };
        } else {
            consumer = (timestamp) -> {
                var value = valueSupplier.get();
                if (value != null) {
                    entry.append(value, timestamp);
                }
            };
        }
        addField(
            entryName,
            level,
            consumer
        );
{%else%}
        if (this.isLazy()) {
            consumer = new LongConsumer() {
                private {{t.java.ValueType}} lastValue = {{t.java.EmptyValue}};
                @Override
                public void accept(long timestamp) {
                    var value = valueSupplier.get();
                    if (value == null) {return;}
                    if (value != lastValue) {
                        entry.append(value, timestamp);
                        lastValue = value;
                    }
                }
            };
        } else {
            consumer = (timestamp) -> {
                var value = valueSupplier.get();
                {%if t.java.ValueType == 'String'%}
                if (value == null) {return;}
                {%endif%}
                entry.append(value, timestamp);
            };
        }

        addField(
            entryName,
            level,
            consumer
        );
{%endif%}
    }
{%endfor%}

    @Override
    public void addSendable(String path, Sendable sendable) {
        if (sendable == null) {
            return;
        }
        var builder = new DataLogSendableBuilder(path);
        sendable.initSendable(builder);
        sendables.add(builder);
    }

    @Override
    public void addSendable(String path, NTSendable sendable) {
        if (sendable == null) {
            return;
        }
        var table = NetworkTableInstance.getDefault().getTable(path);
        var builder = new SendableBuilderImpl();
        builder.setTable(table);
        sendable.initSendable(builder);
        builder.startListeners();
        table.getEntry(".controllable").setBoolean(false);
        sendables.add(builder);
        NetworkTableInstance.getDefault().startEntryDataLog(DataLogManager.getLog(), path, path);
    }

    @Override
    public <R> void addStruct(String entryName, Struct<R> struct, Supplier<? extends R> valueSupplier, LogLevel level) {
        var entry = StructLogEntry.create(log, entryName, struct);

        LongConsumer consumer;

        if (this.isLazy()) {
            consumer = new LongConsumer() {
                private R lastValue = null;

                @Override
                public void accept(long timestamp) {
                    var value = valueSupplier.get();
                    if (value == null) {
                        return;
                    }
                    if (!(value.equals(lastValue))) {
                        entry.append(value, timestamp);
                        lastValue = value;
                    }
                }
            };
        } else {
            consumer = (timestamp) -> {
                var value = valueSupplier.get();
                if (value == null) {
                    return;
                }
                entry.append(value, timestamp);
            };
        }

        addField(
                entryName,
                level,
                consumer);
    }

    @Override
    public <R> void addStructArray(String entryName, Struct<R> struct, Supplier<R[]> valueSupplier, LogLevel level) {
        var entry = StructArrayLogEntry.create(log, entryName, struct);

        LongConsumer consumer;

        if (this.isLazy()) {
            consumer = new LongConsumer() {
                private R[] lastValue = null;

                @Override
                public void accept(long timestamp) {
                    var value = valueSupplier.get();
                    if (value == null) {
                        return;
                    }
                    if (!(Arrays.deepEquals(value, lastValue))) {
                        entry.append(value, timestamp);
                        lastValue = value;
                    }
                }
            };
        } else {
            consumer = (timestamp) -> {
                var value = valueSupplier.get();
                if (value == null) {
                    return;
                }
                entry.append(value, timestamp);
            };
        }

        addField(
                entryName,
                level,
                consumer);
    }

    @Override
    public <R> void putStruct(String entryName, Struct<R> struct, R value, LogLevel level) {
        if (level == LogLevel.NOT_FILE_ONLY && Monologue.isFileOnly()) {
            return;
        }
        if (value == null) {
            return;
        }

        StructLogEntry.create(log, entryName, struct).append(value);
    }

    @Override
    public <R> void putStructArray(String entryName, Struct<R> struct, R[] value, LogLevel level) {
        if (level == LogLevel.NOT_FILE_ONLY && Monologue.isFileOnly()) {
            return;
        }
        if (value == null) {
            return;
        }
        StructArrayLogEntry.create(log, entryName, struct).append(value);
    }

    @Override
    public boolean isNT() {
        return false;
    }
}